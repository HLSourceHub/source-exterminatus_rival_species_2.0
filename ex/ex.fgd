// Generated by LibModMaker at 08/07/2018 17:09:38
@include "base.fgd"
@BaseClass = EX_Objective
[
	display_name(string) : "Display name token" 
	cameraname(target_destination) : "Camera Entity" 
	order(choices) : "Order" : 0 =
	[
		0 : 0
		1 : 1
		2 : 2
		3 : 3
		4 : 4
		5 : 5
		6 : 6
		7 : 7
		8 : 8
		9 : 9
	]

]

@FilterClass base(BaseFilter) size(-8 -8 -8, 8 8 8) = filter_activator_team:
"A filter that filters by the team of the activator."
[
	filterteam(choices) : "Filter Team Number" : 2 =
	[
	]

]

@PointClass base(prop_physics) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_physics_respawnable:
"This class is the same as prop_physics, except it respawns after it breaks"
[
	RespawnTime(float) : "Respawn Time"  : 60
]

@PointClass base(Targetname, Angles) size(-8 -8 0, 8 8 72) = ex_objective:
"Exterminmatus mission objective, a node in the mission tree"
[
	spawnteam(choices) : "Initial Team" : 0 =
	[
		0 : "Neutral"
		2 : "Tyranid"
		3 : "Imperial"
		4 : "Chaos"
	]

	displayname(string) : "Name Token" 
	humannext(target_destination) : "Next Imperial Objective" 
	tyranidnext(target_destination) : "Next Tyranid Objective" 
	// Inputs
	input Captured(integer) : "Tell the Objective it has been captured"
	// Outputs
	output OnHumanCapture(integer) : "Activates when the Objective is captured by the Imperium"
	output OnTyranidCapture(integer) : "Activates when the Objective is captured by the Tyranids"
	output OnChaosCapture(integer) : "Activates when the Objective is captured by the Chaos"
	output OnBecomeTarget(integer) : "Activates when the Objective becomes the Target"
]

@PointClass base(Targetname, Angles) size(-8 -8 -8, 8 8 8) = ex_filter_team:
"Exterminmatus team based filter"
[
	nidblocked(choices) : "Tyranids Blocked" : 0 =
	[
		0 : "Unblocked"
		1 : "Blocked"
	]

	impblocked(choices) : "Humans Blocked" : 0 =
	[
		0 : "Unblocked"
		1 : "Blocked"
	]

	csmblocked(choices) : "Chaos Blocked" : 0 =
	[
		0 : "Unblocked"
		1 : "Blocked"
	]

	// Inputs
	input Activate(integer) : "Activate this entity"
	input ToggleHuman(integer) : "Toggle blocking of activations by Human team players"
	input ToggleTyranid(integer) : "Toggle blocking of activations by Tyranid team players"
	input ToggleChaos(integer) : "Toggle blocking of activations by Chaos team players"
	// Outputs
	output OnActivate(integer) : "Outputs when an activate input is passed by the filter"
	output HumanActivated(integer) : "Outputs when a human input is passed by the filter"
	output TyranidActivated(integer) : "Outputs when a tyranid input is passed by the filter"
	output ChaosActivated(integer) : "Outputs when a chaos input is passed by the filter"
	output OnBlocked(integer) : "Outputs when an activate input is blocked by the filter"
	output HumanBlocked(integer) : "Outputs when a human input is blocked by the filter"
	output TyranidBlocked(integer) : "Outputs when a tyranid input is blocked by the filter"
	output ChaosBlocked(integer) : "Outputs when a chaos input is blocked by the filter"
]

@PointClass base(Targetname, Angles) size(-8 -8 -8, 8 8 8) = ex_filter_one_team:
"Exterminmatus team based filter"
[
	team(choices) : "Filter Team" : 0 =
	[
		0 : "Neutral"
		2 : "Tyranid"
		3 : "Imperial"
		4 : "Chaos"
	]

	blocked(choices) : "Start Blocked" : 0 =
	[
		0 : "Unblocked"
		1 : "Blocked"
	]

	// Inputs
	input Activate(integer) : "Activate this entity"
	input StartBlocking(integer) : "Block activations by members of my team"
	input StopBlocking(integer) : "Allow activations by members of my team"
	// Outputs
	output OnActivate(integer) : "Outputs when an activate input is passed by the filter"
	output OnBlocked(integer) : "Outputs when an activate input is blocked by the filter"
]

@PointClass base(Targetname, Angles) size(-80 -80 0, 80 80 224) = ex_dropzone:
"Exterminmatus spawn point, must be asscociated with an objective"
[
	objectivename(target_destination) : "Objective" 
	// Outputs
	output OnSpawn(integer) : "Outputs when a player spawns at this spot"
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = ex_randombranch:
"When it's randomize input is triggered a random branch output will be triggered, all brnaches have an equal chance of being triggered"
[
	// Inputs
	input Randomize(void) : "Randomize"
	// Outputs
	output OnBranch1(void) : "A random output"
	output OnBranch2(void) : "A random output"
	output OnBranch3(void) : "A random output"
	output OnBranch4(void) : "A random output"
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = ex_gameplay:
"co-ordinates Wave Spawning and Victory between map entities and the mod.  One and One Only per map"
[
	humanstart(target_destination) : "Human Start Objective" 
	tyranidstart(target_destination) : "Tyranid Start Objective" 
	chaosstart(target_destination) : "Chaos Start Objective" 
	textfile(string) : "Translation File Name" 
	startmission(target_destination) : "Start Mission" 
	humanspawnmode(choices) : "Human Spawn Mode" : 0 =
	[
		0 : "Advance"
		1 : "Static"
	]

	tyranidspawnmode(choices) : "Tyranid Spawn Mode" : 0 =
	[
		0 : "Advance"
		1 : "Static"
	]

	chaosspawnmode(choices) : "Chaos Spawn Mode" : 0 =
	[
		0 : "Advance"
		1 : "Static"
	]

	defaulttimer(target_destination) : "Default Timer" 
	// Inputs
	input HumanWin(void) : "Tell the game humans won"
	input TyranidWin(void) : "Tell the game tyranids won"
	input ChaosWin(void) : "Tell the game chaos won"
	input Award(integer) : "Give an award, The parameter can specify how many points to give"
	// Outputs
	output OnHumanSpawnWaveReady(void) : "The human team is ready to spawn"
	output OnTyranidSpawnWaveReady(void) : "The tyranid team is ready to spawn"
	output OnChaosSpawnWaveReady(void) : "The chaos team is ready to spawn"
	output OnHumanKill(void) : "An imperial player has made a kill"
	output OnTyranidKill(void) : "An tyranid player has made a kill"
	output OnChaosKill(void) : "An chaos player has made a kill"
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = ex_shell_spot:
"Shelling effect location"
[
	trigger_radius(integer) : "Trigger radius"  : 1000
	effect_radius(integer) : "Effect radius"  : 1400
	damage_radius(integer) : "Damage radius"  : 1400
	damage(integer) : "Damage"  : 30
	amplitude(float) : "Amplitude"  : 4
	frequency(float) : "Frequency"  : 128
	whizz(sound) : "Whizz sound"  : "Weapon_Mortar.Incomming"
	bang(sound) : "Bang sound" 
	trigger_delay(float) : "Trigger delay"  : 8
	reset_delay(float) : "Reset delay"  : 20
	// Inputs
	input Activate(void) : "Activate this effect"
	// Outputs
	output OnActivate(void) : "This effect has Activated"
	output OnExplode(void) : "The this effect has Exploded"
]

@PointClass base(Targetname) size(-144 -144 -0, 144 144 144) = ex_dropship:
"Used to illustrate re-enforcing troops being airlifted into the battle zone."
[
	target(target_destination) : "First Stop Target" :
	"will spawn at this path_track. It will also turn to face direction indicated by the 'Orientation Type' setting."
	team(choices) : "Initial Team" : 3 =
	[
		2 : "Tyranid"
		3 : "Imperial"
	]

	// Inputs
	input StartFlying(void) : "Start Flying" 
	input StartLanding(void) : "Start Landing"
	input StartLanded(void) : "Start Disembarking"
	input StartTakeoff(void) : "Start Takeoff"
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = ex_mission:
"Tells the teams what they should be doing to achieve their current mission"
[
	team1(string) : "The non-imperial mission text from mapname_lang.txt" 
	team2(string) : "The imperial mission text from mapname_lang.txt" 
	// Inputs
	input ActivateMission(void) : "Make this mission current"
]

@PointClass base(Targetname, Parentname, Angles) cylinder(255 255 255, targetname, target, radius, targetname, targetname, radius) color(255 192 0) size(16 16 16) = ex_dropship_path:
"An entity used to build paths for ex_dropship entities to follow. Each ex_dropship_path is a node on the path, each holding the name of the next ex_dropship_path in the path."
[
	spawnflags(flags) =
	[
		1 : "Disabled" : 1
		2 : "Fire once" : 1
		8 : "Disable dropship" : 1
		16 : "Teleport to THIS path" : 1
	]

	objective(target_destination) : "Objective Name" 
	target(target_destination) : "Next Stop Target" 
	objectivenext(target_destination) : "Objective Target" 
	altpath(target_destination) : "Branch Path" 
	speed(float) : "New Dropship Speed"  : 0 :
	"This speed must be a positive value that is less than the train's max speed. A value of 0 will cause no change in the train's speed."
	radius(float) : "Path radius"  : 0
	setstate(choices) : "Set Dropship State" : 1 =
	[
		1 : "Flying"
		2 : "Landing"
		3 : "Disembarking"
		4 : "LiftOff"
		5 : "No Chnage"
	]

	// Inputs
	input ToggleAlternatePath(void) : "Cause the track to toggle to/from its alternate path."
	input EnableAlternatePath(void) : "Enable the alternate path of the track."
	input DisableAlternatePath(void) : "Disable the alternate path of the track."
	input TogglePath(void) : "Cause the track to toggle on/off/"
	input EnablePath(void) : "Enable the track."
	input DisablePath(void) : "Disable the track."
	// Outputs
	output OnPass(void) : "Fired when any entity following this path passes this path_track node."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = ex_award:
"Give additional awards to the triggering player"
[
	// Inputs
	input Activate(integer) : "Give an award, The parameter specifies how many points to give"
	// Outputs
	output OnActivate(void) : "Points have been awarded"
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = ex_team_award:
"Give additional awards to a specific team"
[
	splitrewards(choices) : "Split Rewards?" : 1 =
	[
		0 : "Give the specified points to all players"
		1 : "Split the points between all the players"
	]

	rewardteam(choices) : "Reward Team" : 3 =
	[
		2 : "Tyranids"
		3 : "Imperium"
		4 : "Chaos"
	]

	// Inputs
	input Activate(integer) : "Give an award, The parameter specifies how many points to give"
	input SetTeam(integer) : "Specify which team should be rewarded"
	// Outputs
	output OnActivate(void) : "Points have been awarded"
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = ex_timer:
"Countdown to a named event"
[
	title(string) : "The token to display next to the timer" 
	length(integer) : "The length of time (in seconds) the timer lasts" 
	// Inputs
	input Start(void) : "Start counting down from the begining"
	input Pause(void) : "Pause a running countdown"
	input Resume(void) : "Resume a paused countdown"
	input Stop(void) : "Stop a running countdown"
	// Outputs
	output OnFinish(void) : "The countdown has completed"
]

@PointClass base(Targetname, EX_Objective, Angles) size(-8 -8 -8, 8 8 8) = ex_start_objective:
"Start Point Objective"
[
]

@PointClass base(Targetname, EX_Objective, Angles) studio("models/gameplay/objective.mdl") = ex_capture_objective:
"Capture Point Objective"
[
	filter(target_destination) : "Filter" 
	// Inputs
	input Captured(integer) : "Force capture"
	// Outputs
	output OnStartCapture(integer) : "Capture is in progress"
	output OnCancelCapture(integer) : "Capture has been cancelled"
	output OnHumanCapture(integer) : "Activates when the Objective is captured by the Imperium"
	output OnTyranidCapture(integer) : "Activates when the Objective is captured by the Tyranids"
	output OnChaosCapture(integer) : "Activates when the Objective is captured by the Chaos"
]

@PointClass base(Targetname, Angles) studio("models/gameplay/AmmoShrine2.mdl") = ex_ammo_shrine:
"Imperial Ammo Dispenser"
[
	IsFree(choices) : "Give Ammo for Free" : 0 =
	[
		0 : "Use Reward Points"
		1 : "Free Ammo"
	]

]

@PointClass base(Targetname, Angles) studio("models/gameplay/tarantula.mdl") = ex_turret_point:
"Defensive Turret Location"
[
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_class.vmt") = ex_team_filter:
"A filter that filters by the team of the activator."
[
	impcancap(choices) : "Imperium can Activate" : 1 =
	[
		0 : "Cannot Activate"
		1 : "Can Activate"
	]

	nidcancap(choices) : "Tyranids can Activate" : 1 =
	[
		0 : "Cannot Activate"
		1 : "Can Activate"
	]

	chaoscancap(choices) : "Chaos can Activate" : 1 =
	[
		0 : "Cannot Activate"
		1 : "Can Activate"
	]

	// Inputs
	input ImpCanCap(void) : "Enable Capping by Imperium"
	input ImpCannotCap(void) : "Disable Capping by Imperium"
	input NidCanCap(void) : "Enable Capping by Tyranids"
	input NidCannotCap(void) : "Disable Capping by Tyranids"
	input ChaosCanCap(void) : "Enable Capping by Chaos"
	input ChaosCannotCap(void) : "Disable Capping by Chaos"
]

@NPCClass base(BaseNPC) studio("models/servoskull.mdl") = npc_servoskull:
"Servo Skull"
[
	spawnflags(flags) =
	[
		65536 : "No Dynamic Light" : 1
	]

	spotlightlength(integer) : "SpotlightLength"  : 500
	spotlightwidth(integer) : "SpotlightWidth"  : 50
	spotlightdisabled(choices) : "SpotlightDisabled" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	ShouldInspect(choices) : "Should inspect" : 1 =
	[
		0 : "No"
		1 : "Yes"
	]

	OnlyInspectPlayers(choices) : "Only Inspect Players" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	NeverInspectPlayers(choices) : "Never Inspect Players" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input DisableSpotlight(void) : "DisableSpotlight"
	input InspectTargetPhoto(string) : "Tells the scanner to photograph the given entity, named by classname or by target name. !activator or !player works here also."
	input InspectTargetSpotlight(string) : "Tells the scanner to spotlight the given entity, named by classname or by target name. !activator or !player works here also."
	input InputSetFlightSpeed(integer) : "Sets the flight speed of the scanner"
	input InputShouldInspect(integer) : "Set whether should inspect or not"
	input SetFollowTarget(string) : "Set target to follow until told otherwise"
	input ClearFollowTarget(void) : "Stop following our target"
	input SetDistanceOverride(float) : "Override the distance the scanner will attempt to keep between inspection targets and itself"
]

@SolidClass base(BreakableBrush, Origin, RenderFields, Shadow, EX_Objective, Angles) = ex_break_objective:
"Breakable Objective"
[
	minhealthdmg(integer) : "Min Damage to Hurt"  : 0
	_minlight(string) : "Minimum Light Level" 
	physdamagescale(float) : "Physics Impact Damage Scale"  : "1.0"
]

